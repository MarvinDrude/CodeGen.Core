using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Engines;
using CodeGen.Common.CodeGen;
using CodeGen.Common.CodeGen.Fluent;
using CodeGen.Common.CodeGen.Models.Common;
using CodeGen.Core.Perfs.Config;
using Microsoft.CodeAnalysis;
using CodeGenHelpers;
using CodeBuilder = CodeGen.Common.CodeGen.CodeBuilder;

namespace CodeGen.Core.Perfs.CodeGen;

[SimpleJob(RunStrategy.Throughput, iterationCount: 6), Config(typeof(BenchmarkConfig))]
[MinColumn, MaxColumn, MeanColumn, MedianColumn, MemoryDiagnoser]
public class FluentBenchmark
{
   [Benchmark]
   public char SimpleNoAllocationBenchmark()
   {
      // this example does not use heap allocations besides the ToString at the end if needed
      // this setup is probably already pushing the safe limit of sack allocations
      // general rule of thumb can be 1kb to 4kb at max depending on nesting etc.
      var builder = new CodeBuilder(
         stackalloc char[1024],
         stackalloc char[128],
         3, ' ');
      builder.SetTemporaryBuffer(stackalloc byte[1024]);
      
      builder.NameSpace.Usings = [
         "System.Test",
         "System.A",
         "System.B"
      ];
      builder.NameSpace.EnableNullable = true;
      builder.NameSpace.AutoGenerated = true;
      
      builder.NameSpace.Path = "My.NameSpace";
      builder.NameSpace.Render();

      // due to the limitation of possible zero heap allocation + the temporary buffer
      // u will always need to create classes one at a time per CodeBuilder until u flush with Render()
      var test = builder.CreateClass();
      test
         .SetName("TestA")
            .IsRecordClass()
            .IsPartial()
            .IsInternal()
            .IsUnsafe()
         .SetBaseClassName("TestBase")
            .AddInterfaceName("IInterfaceTwo")
            .AddInterfaceName("IInterfaceThree");
      
      // Add generic parameters to class if needed
      var genericParamOne = test.AddGenericParameter("TParameter");
      genericParamOne
         .AddConstraint("notnull")
         .Done(); // write it to the current class generic temporary buffer

      var genericParamTwo = test.AddGenericParameter("TResult");
      genericParamTwo
         .AddConstraint("struct")
         .AddConstraint("allows ref struct")
         .Done(); 

      test.Render(); 
      // flush class header to free temporary buffer (stack allocated is limited)
      // u can always choose to not flush and the temporary buffer will be heap allocated automatically
      // as soon as the stack allocated buffer is exceeded

      builder.Writer.WriteLine("private static readonly string StaticFieldTest;");
      builder.Writer.WriteLine();

      builder.Writer.WriteLine("private int _numberField;");
      builder.Writer.WriteLine("private int _numberField1;");
      builder.Writer.WriteLine();
      // you can write normal lines and text between Render() flushes whenever you need custom code
      
      var staticConstructor = test.AddConstructor(AccessModifier.None);
      staticConstructor
         .IsStatic()
         .Done(); // write it to the current class generic temporary buffer
      test.Render(); // flush the static constructor header
      
      builder.Writer.WriteLine("StaticFieldTest = \"Look a string!\";");
      builder.Writer.CloseBody();
      builder.Writer.WriteLine();
      
      var instanceConstructor = test.AddConstructor(AccessModifier.Public);
      instanceConstructor
         .WithThisCall()
         .AddThisParameter("number") // add one parameter to : this() call
         .AddThisParameter("0")
         .AddParameter("int", "number")
         .Done(); 
      test.Render();
      builder.Writer.CloseBody();
      builder.Writer.WriteLine();

      var instanceConstructorImpl = test.AddConstructor(AccessModifier.Public);
      instanceConstructorImpl
         .AddParameter("int", "number")
         .AddParameter("int", "number1")
         .Done();
      test.Render();
      builder.Writer.WriteLine("_numberField = number;");
      builder.Writer.WriteLine("_numberField1 = number1;");
      builder.Writer.CloseBody();
      builder.Writer.WriteLine();

      var genericMethod = test.AddMethod("GenericMethodName");
      genericMethod
         .IsInternal()
         .AddModifier(MethodModifier.Async | MethodModifier.Static)
         .AddParameter("TMethod", "input")
         .SetReturnType("Task<bool>");
      
      var genericMethodParameter = genericMethod.AddGenericParameter("TMethod");
      genericMethodParameter
         .AddConstraint("notnull")
         .Done();
      
      genericMethod.Done();
      test.Render();

      builder.Writer.WriteLine("// test comment");
      builder.Writer.WriteLine("throw new System.NotImplementedException();");
      
      builder.Writer.CloseBody();
      
      builder.Writer.CloseBody();
      
      // WrittenSpan is full class as ReadOnlySpan<char> if you can work with that and has no additional heap allocation
      var cha = builder.Writer.WrittenSpan[0];
      // ToString allocates a new heap string based on WrittenSpan
      //var str = builder.ToString();
      
      // Dispose should always be called (best in a finally) but is only responsible for freeing any heap allocations
      // that were necessary (in this example there were none)
      builder.Dispose();

      return cha;
   }

   [Benchmark]
   public char SimpleSmallNoAllocationBenchmark()
   {
      var builder = new CodeBuilder(
         stackalloc char[512],
         stackalloc char[128],
         3, ' ');
      builder.SetTemporaryBuffer(stackalloc byte[1024]);

      var test = builder.CreateClass();
      test.SetName("TestClassName")
         .IsPartial()
         .Render();

      builder.Writer.WriteLine("private readonly int _numberField;");
      builder.Writer.WriteLine();
      
      var instanceConstructor = test.AddConstructor(AccessModifier.Public);
      instanceConstructor
         .AddParameter("int", "number")
         .Done(); 
      test.Render();
      
      builder.Writer.WriteLine("_numberField = number;");
      
      builder.Writer.CloseBody();
      
      // close class
      builder.Writer.CloseBody();
      
      // zero allocation char span
      var cha = builder.Writer.WrittenSpan[0];
      // heap allocated string if needed
      var str = builder.ToString();
      builder.Dispose();
      
      return cha;
   }

   [Benchmark]
   public char CompareCodeGenHelpersBuilder()
   {
      var builder = CodeGenHelpers.CodeBuilder.Create("My.NameSpace")
         .Nullable()
         .WithAutoGeneratedMessage("auto generated")
         .AddNamespaceImport("System.Test")
         .AddNamespaceImport("System.A")
         .AddNamespaceImport("System.B")
         .AddClass("TestA")
         .Sealed()
         .SetBaseClass("TestBase")
         .AddInterface("IInterfaceTwo")
         .AddInterface("IInterfaceThree")
         .AddGeneric("TParameter", (b) =>
         {
            b.AddConstraint("notnull");
         })
         .AddGeneric("TResult", (b) =>
         {
            b.AddConstraint("struct");
            b.AddConstraint("allows ref struct");
         })
         .AddConstructor(Accessibility.Public)
         .AddConstructor(Accessibility.Public)
         .WithThisCall(new Dictionary<string, string>()
         {
            ["int"] = "number"
         })
         .Class
         .AddConstructor(Accessibility.Public)
         .AddParameter("int", "number")
         .AddParameter("int", "number1")
         .WithBody((c) =>
         {
            c.AppendLine("_numberField = number;");
            c.AppendLine("_numberField1 = number1;");
         })
         .Class
         .AddMethod("GenericMethodName", Accessibility.Internal)
         .MakeAsync()
         .MakeStaticMethod()
         .AddParameter("TMethod", "input")
         .AddGeneric("TMethod", (x) =>
         {
            x.AddConstraint("notnull");
         })
         .WithBody(x =>
         {
            x.AppendLine("// test comment");
            x.AppendLine("throw new System.NotImplementedException();");
         })
         .AddProperty("StaticFieldTest", Accessibility.Private)
         .SetType("string")
         .MakeStatic()
         .WithReadonlyValue()
         .AddProperty("_numberField", Accessibility.Private)
         .SetType("int")
         .Class
         .AddProperty("_numberField1", Accessibility.Private)
         .SetType("int");;

      var str = builder.Class.Build();
      return str[0];
   }
}