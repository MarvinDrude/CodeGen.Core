
# C# Source Generation Library

This is a lightweight library with useful structs and classes for when C# Source Generators support .NET 10 in the future. Still work in progress..

## Supported features

- Fast zero / low allocation code text writer ‚ö°üìù
- More abstract code text builder on top of the writer üß±üîß

## CodeWriter (least abstract way of generating code)

Just a glorified zero / low allocation text writer as ref struct with some helper methods like OpenBody, CloseBody, UpIndent, DownIndent
```C#
// example with indent of 3 spaces
using var writer = new CodeTextWriter(
   stackalloc char[512],
   stackalloc char[64],
   3, ' ');

writer.WriteLine("public class Test");
writer.OpenBody();
writer.WriteLine("public string StrTest { get; set; }");
writer.WriteLine();
writer.WriteLine("public Test()");
writer.OpenBody();
writer.WriteLine("StrTest = \"Test\";");
writer.CloseBody();
writer.CloseBody();

// if you need the result as a real heap string you will have to call ToString
// if you only need a ReadOnlySpan<char> u can always access writer.WrittenSpan
var strResult = writer.ToString();
```
In this very small example strResult will be the following:
```C#
public class Test
{
   public string StrTest { get; set; }

   public Test()
   {
      StrTest = "Test";
   }
}
```

## CodeBuilder (stateful mode)

More abstract way of generating code with still zero / low allocations. Small example:
```C#
var builder = new CodeBuilder(
   stackalloc char[1024],
   stackalloc char[6],
   1, '\t');

builder.NameSpace.Usings = [
   "System.Test",
   "System.A",
   "System.B"
];
builder.NameSpace.EnableNullable = true;
builder.NameSpace.AutoGenerated = true;

builder.NameSpace.Path = "My.NameSpace";
builder.NameSpace.Render();

builder.Class.Declaration = "public abstract class Test";
builder.Class.BaseDeclarations = [
   "BaseClassOne",
   "IInterfaceTwo"
];
builder.Class.RenderDeclaration();

builder.Method.Modifiers = "public abstract";
builder.Method.ReturnType = "void";
builder.Method.Name = "TestMethod";

builder.Method.Parameters = [
   new MethodParameter()
   {
      Name = "name",
      Type = "string"
   }
];
builder.Method.RenderHeader();

builder.Writer.OpenBody();
builder.Writer.WriteLine("Console.WriteLine(name);");
builder.Writer.CloseBody();

builder.Writer.WriteLine();

builder.Method.Modifiers = "public abstract";
builder.Method.ReturnType = "void";
builder.Method.Name = "AbstractMethod";

builder.Method.IsOnlyHeader = true;
builder.Method.RenderHeader();

builder.Writer.CloseBody();

// if you need the result as a real heap string you will have to call ToString
var strResult = builder.ToString();
```
This stateful building will result in this output string:
```C#
#nullable enable
// <auto-generated>

using System.Test;
using System.A;
using System.B;

namespace My.NameSpace;

public abstract class Test
   : BaseClassOne,
     IInterfaceTwo
{
   public abstract void TestMethod(
      string name)
   {
      Console.WriteLine(name);
   }

   public abstract void AbstractMethod();
}
```

## CodeBuilder (immediate mode)

More abstract way of generating code with still zero / low allocations. Small example:
```C#
var builder = new CodeBuilder(
   stackalloc char[1024],
   stackalloc char[6],
   1, '\t', enableStateBuilders: false); // disable state builder overhead

builder.NameSpaceIm
   .EnableNullable()
   .AutoGeneratedComment()
   .WriteLine()
      .Using("System.Test")
      .Using("System.A")
      .Using("System.B")
      .WriteLine()
   .Set("My.NameSpace")
   .WriteLine();

builder.ClassIm
   .OpenHeader("public abstract class Test")
      .FirstBaseDeclaration("BaseClassOne")
      .NextBaseDeclaration("IInterfaceTwo")
      .CloseBaseDeclaration()
   .CloseHeader()
   .Done()
   .MethodIm.OpenHeader("public", "void", "TestMethod")
      .FirstParameter("string", "name")
   .CloseHeader()
   .OpenBody()
      .WriteLine("Console.WriteLine(name);")
   .CloseBody()
   .WriteLine()
   .OpenHeader("public abstract", "void", "AbstractMethod", false)
   .CloseHeaderNoParameters(true)
   .CloseBody();
```
This immediate building will result in this output string:
```C#
#nullable enable
// <auto-generated>

using System.Test;
using System.A;
using System.B;

namespace My.NameSpace;

public abstract class Test
   : BaseClassOne,
     IInterfaceTwo
{
   public abstract void TestMethod(
      string name)
   {
      Console.WriteLine(name);
   }

   public abstract void AbstractMethod();
}
```
