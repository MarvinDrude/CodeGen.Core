
# 📝 C# Source Generation Library

A lightweight, performance-oriented library that provides efficient building blocks for C# source generation.

> ⚠️ Note: This project is still a work in progress. It is designed with future .NET (≥10) source generator scenarios in mind.

## ✨ Features

- ⚡ Fast, zero/low-allocation text writer (CodeTextWriter)
- 🧱 Composable code builders on top of the writer (CodeBuilder)
- 📝 Fluent APIs for common code-generation patterns (indents, bodies, blocks)
- 🔒 ref struct design ensures stack-only safety and avoids heap allocations

## 📦 Nuget packages

| Project/Package name | Nuget                |
| :-------- | :------------------------- |
| CodeGen.Writing | [![Nuget](https://img.shields.io/badge/nuget-0A66C2?style=for-the-badge&logo=nuget&logoColor=white)](https://www.nuget.org/packages/CodeGen.Writing) |

## 📚 Contents 

- Code Text Generation
   - [CodeWriter](#✍️📝⚡-CodeWriter-least-abstract-way-of-generating-code)
   - [CodeBuilder](#🧱🔧🏗️-CodeBuilder-some-more-useful-helpers)

## ✍️📝⚡CodeWriter (least abstract way of generating code)

CodeWriter is essentially a zero/low-allocation text writer implemented as a ref struct.
It comes with helper methods like OpenBody(), CloseBody(), UpIndent(), and DownIndent().

You can also take advantage of interpolated string handlers so interpolated values never allocate on the heap before writing.
```C#
// example with indent of 3 spaces
var writer = new CodeTextWriter(
   stackalloc char[16], stackalloc char[128],
   3, ' ');
string result;

try
{
   const string str = "Test";

   writer.WriteLineInterpolated($"public class {str}");
   writer.OpenBody();

   writer.WriteLine("public string StrTest { get; set; }");
   writer.WriteLine();

   // does not allocate the interpolated string
   writer.WriteLineInterpolated($"public {str}()");
   writer.OpenBody();
   writer.WriteLine($"StrTest = \"Test\";");
   writer.CloseBody();

   writer.CloseBody();
}
finally
{
   // if you need the result as a real heap string you will have to call ToString
   // if you only need a ReadOnlySpan<char> u can always access writer.WrittenSpan
   result = writer.ToString();
   writer.Dispose();
}

return result;
```

## 🧱🔧🏗️ CodeBuilder (some more useful helpers)
While CodeWriter is minimal and explicit, CodeBuilder introduces convenience helpers for common patterns you often repeat when generating C#.

For example:

- Automatic handling of class/namespace declarations
- Simplified method/property scaffolding
- Higher-level composition without losing performance guarantees

```C#
var builder = new CodeBuilder(
   stackalloc char[1024], stackalloc char[128],
   3, ' ');
try 
{
   // ... build
}
finally 
{
   builder.Dispose();
}
```
The CodeBuilder offers all methods of the CodeTextWriter too, and you can chain them together, since all of them return the CodeBuilder or Module as ref in a fluent fashion.

### 🌐 File Module of the CodeBuilder
Offers most cases for the top of the file that is being generated. Here is a very common example
- Writes the auto generated comment
- Writes #nullable enable
- Writes usings for this file

```C#
builder.File
   .WriteStartAutoGenerated()
      .WriteLine("// Here")
      .WriteLine("// is a message")
      .WriteLineInterpolated($"// Test {x}")
   .WriteEndAutoGenerated()
   .WriteNullableEnable()
      .WriteUsing("NameSpaceA")
      .WriteUsing("NameSpaceB.Test", true);
```

### 🏛️ TypeHeader Module of the CodeBuilder
This can hel you writing the header part of classes/structs/interfaces. It supports:
- Access Modifier
- Modifiers
- Generic Parameters / Constraints
- Primary Constructor
- Base List

Here is a comprehensive example:
```C#
builder.TypeHeader
   .WriteAccessInternal()
   .WriteClassModifiers(ClassModifier.Sealed | ClassModifier.Partial)
   .WriteClass("ClassName")
   .WriteStartGenericParameters()
      .WriteGenericParameter("T")
      .WriteGenericParameter("T2", true)
   .WriteEndGenericParameters()
   .WriteStartParameterList()
      .WriteParameter("string name")
      .WriteParameter("int age")
      .WriteParameterInterpolated(false, false, $"int test = {x}")
   .WriteEndParameterList()
   .WriteStartBaseList()
      .WriteBaseType("BaseClass")
      .WriteBaseType("IInterfaceBase", true)
   .WriteEndBaseList()
   .WriteStartGenericConstraints("T")
      .WriteGenericConstraint("notnull")
      .WriteGenericConstraint("IInterfaceName", true)
   .WriteLineEndGenericConstraints()
   .WriteStartGenericConstraints("T2")
      .WriteGenericConstraint("class")
   .WriteLineEndGenericConstraints()
   .OpenBody();

builder.WriteLine("public static void Test()")
   .OpenBody()
      .WriteLine("Console.WriteLine(\"Test\");")
   .CloseBody();

builder.TypeHeader
   .CloseBody();
```
